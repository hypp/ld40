<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
      <title>LD 40 - The more you have, the worse it is</title>

      <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>

   </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

    <script>

        var keys={
            letft:false,
            right:false,
            forward:false,
            back:false
        };
        window.addEventListener("keydown", handleKeyDown, false);
        window.addEventListener("keyup", handleKeyUp, false);
        function handleKeyDown(evt){    
            if (evt.keyCode==65) {
                //A        
                keys.left=true;    
            }    
            if (evt.keyCode==68) {
                //D        
                keys.right=true;    
            }    
            if (evt.keyCode==87) {
                //W        
                keys.forward=true;    
            }    
            if (evt.keyCode==83) {
                //S        
                keys.back=true;    
            }
        }
        function handleKeyUp(evt) {    
            if (evt.keyCode==65) {        
                keys.left=false;    
            }    
            if (evt.keyCode==68) {
                keys.right=false;    
            }    
            if (evt.keyCode==87) {        
                keys.forward=false;    
            }    
            if (evt.keyCode==83) {        
                keys.back=false;    
            }
        }

            var canvas = document.getElementById("renderCanvas"); // Get the canvas element 

            var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine


            var createRoad = function (scene) {
                var greyMaterial = new BABYLON.StandardMaterial("greyGroundMat", scene);
                greyMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                greyMaterial.backFaceCulling = false;
                var greySegment = BABYLON.Mesh.CreatePlane("greyGround", 20.0, scene);
                greySegment.material = greyMaterial;
                greySegment.setEnabled(false);

                var darkgreyMaterial = new BABYLON.StandardMaterial("darkgreyGroundMat", scene);
                darkgreyMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                darkgreyMaterial.backFaceCulling = false;
                var darkgreySegment = BABYLON.Mesh.CreatePlane("darkgreyGround", 20.0, scene);
                darkgreySegment.material = darkgreyMaterial;
                darkgreySegment.setEnabled(false);

                // Circular race track
                var x = 40; // meters from origo
                var y = 0; // ground
                var z = 0; // first segment of the road

                var numSegments = 20;
                var angleIncrement = 360.0 / numSegments;
                var angle = 0.0;

                for (let index = 0; index < numSegments; index++) {
                    var angleRadians = angle * Math.PI / 180.0;

                    var xp = z*Math.sin(angleRadians) + x*Math.cos(angleRadians);
                    var yp = y
                    var zp = z*Math.cos(angleRadians) - x*Math.sin(angleRadians);

                    var segment;
                    if (index % 1 == 0) {
                        segment = darkgreySegment.createInstance("index" + index);
                    } else {
                        segment = greySegment.createInstance("index" + index);
                    }
                    segment.position = new BABYLON.Vector3(xp, yp, zp);
                    segment.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.LOCAL);
                    segment.rotate(BABYLON.Axis.Z, -angleRadians, BABYLON.Space.LOCAL);                    
                    segment.setEnabled(true);
                    segment.physicsImpostor = new BABYLON.PhysicsImpostor(segment, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);

                    angle += angleIncrement;
                    //z += 20.0;
                }
            }

            var player;

            var createPlayer = function(scene) {
                player = BABYLON.MeshBuilder.CreateSphere("player", {diameter: 0.5}, scene);
                player.position = new BABYLON.Vector3(40, 1, 0);
                player.physicsImpostor = new BABYLON.PhysicsImpostor(player, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);

                playerTorso = BABYLON.MeshBuilder.CreateSphere("playerTorso", {diameter: 0.4}, scene);
                playerTorso.parent = player;
                playerTorso.position = new BABYLON.Vector3(0, 0.5/2+0.4/2, 0);
                //playerTorso.physicsImpostor = new BABYLON.PhysicsImpostor(playerTorso, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);

                playerHead = BABYLON.MeshBuilder.CreateSphere("playerTorso", {diameter: 0.3}, scene);
                playerHead.parent = playerTorso;
                playerHead.position = new BABYLON.Vector3(0, 0.4/2+0.3/2, 0);
                //playerTorso.physicsImpostor = new BABYLON.PhysicsImpostor(playerTorso, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);

                playerNose = BABYLON.MeshBuilder.CreateSphere("playerTorso", {diameter: 0.05}, scene);
                playerNose.parent = playerHead;
                playerNose.position = new BABYLON.Vector3(0, 0, (0.3/2+0.05/2)*-1.0);
                //playerTorso.physicsImpostor = new BABYLON.PhysicsImpostor(playerTorso, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);
            }

            var directionVector = new BABYLON.Vector3();
            window.addEventListener("mousemove", function () {
                var pickResult = scene.pick(scene.pointerX, scene.pointerY);
                if (pickResult.hit) {
                    var direction = pickResult.pickedPoint;
                    directionVector = direction.subtract(player.position);  
                    player.lookAt(direction);
                }
            });

            /******* Add the create scene function ******/
            var createScene = function () {

                var scene = new BABYLON.Scene(engine);
                scene.enablePhysics();
                
                    // Lights
                    var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2), scene);
                    var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, -5, -2), scene);

                    createRoad(scene)
                    createPlayer(scene)

                    // Parameters: name, position, scene    
                    var camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 10, -10), scene);

                    camera.radius = 2;
                    camera.heightOffset = 2;
                    camera.rotationOffset = 0;
                    camera.cameraAcceleration = 0.005
                    //camera.maxCameraSpeed = 10
                    camera.attachControl(canvas, true);
                    //camera.target = targetMesh;   // version 2.4 and earlier
                    camera.lockedTarget = player; //version 2.5 onwards

                
                    //Then apply collisions and gravity to the active camera
                    //camera.checkCollisions = false;
                    //camera.applyGravity = false;
                
                    //Set the ellipsoid around the camera (e.g. your player's size)
                    //camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
                
                    //finally, say which mesh will be collisionable
//                    ground.checkCollisions = true;
//                    box.checkCollisions = true;
                
                    scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5);

                        return scene;
                };

                /******* End of the create scene function ******/    

                var scene = createScene(); //Call the createScene function

            engine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene
                if (keys.forward==1) {		
                    player.position.x += directionVector.x / 100 ;		
                    player.position.z += directionVector.z / 100 ;			
                }

                scene.render();
            });


            window.addEventListener("resize", function () { // Watch for browser/canvas resize events
                    engine.resize();
            });

            
    </script>

   </body>

</html>
